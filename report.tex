\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{url}
\usepackage[a4paper, total={6in, 10in}]{geometry}

\title{\textbf{Expense Tracker Report}}
\author{ Ciaglia, Floriana\\ 
\texttt{flociaglia@u.boisestate.edu}
\and
Hull, Bethany\\
\texttt{bethanyhull@u.boisestate.edu}
\and
Macias, Alejandro\\ 
\texttt{alejandromacias607@u.boisestate.edu}
\and
Rao, Daniel\\
\texttt{danielrao@u.boisestate.edu}}

\date{November 30th, 2020}

\begin{document}

\maketitle

\begin{abstract}
 Expense Tracker is a mobile application written in Swift created by our group with the purpose of building a tool which would aid the tracking of spending habits. 

  \end{abstract}

  \section{Introduction}
  \label{sec:into}
 
  Our group decided to choose the Swift language for a variety of reasons. The majority of us are Apple devices lovers. Using iPhones and Mac-Books on a daily basis, we developed a desire to learn what is behind the software we use every day. We became curious to learn what the programming language used to build many of the applications we have downloaded on our phones looks like and what some of its main characteristics are. Apple products are known to be appealing to the eye and easy to navigate, therefore, another reason why we were drawn to choose Swift for this project was to acquire the knowledge to, not only replicate but, invent new Apple-style looking apps. \par
  
  \vskip 0.2in
 
  Selecting a language used specifically for OS development, we felt compelled to direct our group project towards an iOS mobile application. We chose to build a tool that would be of reasonable size for the limited amount of time we had available and, at the same time, that would present us with the queries and challenges that would push us to learn the language in this short time. Moreover, we wanted to develop a tool that would be of use to anyone by choosing a topic that is universal. Our application is called "Expense Tracker" and its purpose is to aid users in tracking their personal expenses. It keeps a balance between the spent and the incoming money by allowing the user to add new categories of expenses, it provides the user with charts that portray their spending trends and it allows for modifications to the user's personal information in case needed.  
  
  \vskip 0.2in
  
  The Swift language has shifted the way Apple developer’s create applications for all the different platforms. SwfitUI specifically has given developers the ability to implement a creative and comfortable interface for users. The language offers customization features such as animations, effects, menus, etc. The integration of objects from kits into SwiftUI from other frameworks makes iOS development a lot easier from a developer perspective. With that being said, in order to achieve our goal of creating an iOS mobile application, the Swift language was our best option to proceed with this project. 

  
\section{A Short Overview}
The Expense Tracker app has five different navigation views. By default, the app launches to the Home View where the user can see his/her current balance divided into money spent and money saved. The Category View allows the user to view what kinds of expenses he/she had in the recent past and under what categories they fall into. The Add Expense View allows the user to add a new expense attached to its category, date and a short description. The Chart View shows a pie chart of the user's spending trends portraying which categories the majority of the expenses fall into. Finally, the Profile View is where the users can set up their personal information including their name, monthly income and profile picture. 
 In Figure \ref{fig:category} below we can see a screenshot of each of the navigation tabs that compose the Expense Tracker.
% \begin{figure}[H]
% \centering
% \includegraphics[scale=.5]{sandwich theorem.PNG}
% \caption{The Unit Circle \label{fig1}}
% \end{figure}


\begin{figure}[H]
\makebox[\textwidth]{%
\includegraphics[width=50mm]{HomeView.png}%
\hspace{.05cm}
\includegraphics[width=50mm]{CategoryView.png}%
}\\[0.5cm]% If you want some vertical space
\makebox[\textwidth]{%
\includegraphics[width=50mm\textwidth]{AddExpense.png}%
\hfill    
\includegraphics[width=50mm\textwidth]{pieChart.png}%
\hfill    
\includegraphics[width=50mm\textwidth]{ProfileView.png}%
}%
\caption{Starting from the upper left corner, we can see the home view page, followed by the category view page to its right. On the second line, we can see the AddExpense view to the left and the pie chart view and the profile view going to the right.}
\label{fig:OlimpicCircleTT1}
\end{figure}


%   \begin{figure}[H]
%   \centering
%       \includegraphics[width=60mm]{CatogoryView.png}
%       \caption{The Category view.}
     
%       \label{fig:category}
%   \end{figure}


\section{The Swift Programming Language}
The Swift programming language was developed by Apple as an alternative to Objective-C. It was introduced as “Objective-C without the C”, and true to that concept swift employs modern language attributes to improve on common complaints programmers had with Objective-C, such as exposed pointers. Swift is built to be very fast and to be compatible with programs that have been previously written in Objective-C. It is a compiled language, that is static and uses late binding.

\subsection{General Syntax and Variables  \cite{Swift}\cite{SwiftPL}}
In general, Swift looks really similar to javascript, C languages, or java in its use of brackets and parentheses and functions very similarly. It does not required a semicolon after each statement, though they can be used to separate statements that are on the same line.

\vskip 0.2in

Similar to javascript,  \emph{let} is used for constants, and \emph{var} is used for variables -- however, unlike javascript,  the language is strongly typed. Types can be declared or inferred through declaration. Declared types are placed after the name, for example: \par

\begin{verbatim} var foo: String \end{verbatim} 

Swift also has a very interesting system for working with variables that may not have a value assigned to them yet, known as “optionals”, declared as the variable type with a question mark after it \emph{(Int?)}.  Optionals function as a different type than the declared type and can be checked for a null value without throwing an error. If the value is not null the variable can be “unwrapped” and the value used. This allows more flexibility for developers and helps eliminate the null-pointer errors that are common in Objective-C. \par

\subsection{Control flow and operators}
The syntax of the operators and control flow statements is very similar to python.  For example a for..in statement to use with arrays and collections and the elimination of the incrementer (++) and decrementer(- -) used in other popular modern languages and replacing them with the more readable +=1 or -=1. There are also some interesting features that allow for customized equality testing for operators. For example when comparing two objects using ‘==’ we had to add the implement “Equitable” in our class which created a function stub that was named “==’. Using this Swift will automatically use this method when comparing two objects of this type, similar to the equals method in Java.

\subsection{Functions}
Perhaps some of the most interesting syntactical differences we encountered were when writing and using functions. Swift uses named parameters in functions, which were difficult to get used to, as none of us have used them before, but it is easy to see how they can contribute to cleaner readable code. Swift also has a really interesting syntax that is reminiscent of arrow functions in other languages. Here is an example of a function declaration and call in Swift, showing the named parameter and return type declaration. 

\begin{verbatim} 
func example(test: String) -> String { return test }
 
example(test: “Hello!)
\end{verbatim}

\subsection{Use within SwiftUI}
Using the SwiftUI framework was one of the most difficult parts of building the app for our group. SwiftUI is the new standard app framework for ios apps and it functions like other modern web and app frameworks-- keeping track of view layers in a parent-child relationship that inherits data downward in the tree, much like web frameworks such as vue, react, or angular. We chose to use SwiftUI over the old storyboard framework because it gave us more experience with the swift language as Storyboard has an XML frontend and experience with a modern UI framework. \par

\vskip 0.2in

One of the interesting things we found in SwiftUI was the UI limitations Apple put on the available UI objects to assure that the app fit the “Apple brand” look while allowing flexibility for styling. Even after we applied our own design elements our app clearly looked like an ios app. \par

\vskip 0.2in

The biggest challenge we had was passing information objects through the views and getting it to update correctly. The views in SwiftUI relate to each other in a very similar way that objects relate to each other in object oriented languages. In the long run this ends up being a very good way to organize a UI and to reuse code, but in the beginning it’s very difficult to conceptualize a UI in this way. As a group we would often build a UI to look a certain way, only to find out that we couldn't get the correct data to the view because we didn't think about it as an object-- we didn't consider how the object fit in the whole project. 

\vskip 0.2in

While we grew to like the language the more we learned about it, there are a few things that we wish were better about the Swift language and what comes with it. We found the SwiftUI framework to make the UI styling very little intuitive and very limiting. In addition, due to the fact that it is a fairly new framework, we often struggled to find good and informative documentation. Finally, one aspect that made debugging challenging while developing this app was the Swift compiler error messages which, often times, were cryptic. 

\section{Project Design and Analysis}

For this project we organized the information based on five main views and three data classes. The three classes were an array of expense objects with information about each expense recorded, A user class with information about the user, and a category class which kept track of categories the user adds to the App. These objects we read and wrote to json files stored in the main project file system for data persistence. A navigation view functioned as the "parent" view for the app where the data objects were instantiated and declared environment variables, allowing them to be accessed by any other descendent of the navigation view. The navigation view also allowed for a menu bar to overlay all children views for simple navigation between views.

  \vskip 0.2in 
  
From Navigation view the five main views were declared and passed the environment data objects, allowing them to be mutated by each of the views. One of the common bugs we encountered while creating each of the views was that group members would create variables in the views using pieces of the environment object data then expect the object to update when that variable was changed. However, it because clear pretty fast that these variables were holding a copy of the data, not a pointer to the data, and the data object needed to be mutated directly for the data to update and persist. For this bug we used the computed variables in SwiftUI; variables that are defined as the return value of a function that triggers an update and recomputes whenever the data within them changes. \par

  \vskip 0.2in 
 
 In terms of design one of thee greatest challenges we had, and the current majority of our bugs are coming from determining all the edge cases for the user input and giving the user feedback about how the program is working. This idea was new for many of us that hadn't worked a lot with user interfaces. For example when adding an expense a user is currently able to click the add an expense button without filling out all the appropriate form fields. The form fields themselves are not being checked or formatted based on their data type, with error messages sent to the user. And when an expense is entered there is no indication to the user that an expense has been added to the list. This example shows that while our program has the basic functionality what we set out to create, to create an intuitive streamlined UI is much more difficult then we anticipated and these bugs would be the focus of much of our future work with the app.
 


\section{Evaluation}
During the planning phase of our project, we have conducted research that explains how all iOS mobile applications follow similar UI designs for each of their views. Our vision is to let the users navigate throughout the app by themselves without a special manual. We have agreed to follow a similar approach. At the moment the app is opened, a navigation bar is set up horizontally at the bottom to access different views. Each view is set up as a navigation view which consists of each view containing a title at the top. All views that contain text fields have been styled with rounded corners and white background to help aid the user for input. Above each textfield is a title that defines the purpose of each textfield. A blue and green background has been added to most views to symbolize money since that is Expense Tracker’s purpose. The expenses listed in is category view is a List UI element of these categories which allows the user to smoothly scroll through their expenses and tap on them for details. As a result, the ordering of lists in a List UI has allowed the users to also enter an expense of a category type of their choosing.

\vskip 0.2in
    To enhance the applications functionality, we have created a short survey in order to collect some feedback from our testers. We have presented the app to a few people each and asked them to fill out our survey. Below we can find the questions we asked:
\begin{verbatim} 
1. Can you successfully add an expense or income? 
2. Can you add information about yourself?
3. Is the app easy to navigate? 
4. What parts were confusing to you?
5. What did you like?
6. What additional features did you wish the app had? 
\end{verbatim} 

To summarize the collection of feedback we received, the testers found the app fairly easy to navigate and understand. Some of the most common comments we received were: \emph{"Very user-friendly"}, \emph{"Straight forward navigation"} and \emph{"Choice of colors clearly demonstrates the purpose of the application"}. While the feedback was overall positive, we also received some constructive critiques that helped us improve the quality of the application. We were able to implement some of the changes that were suggested to us by our testers, whereas the rest we will keep in mind for future work. People were generally confused about what the Income user input asked for in the profile view referred to. We clarified this by changing the label to \emph{Monthly Income}; confusion also arose about why the income was included in the Expenses pie chart - according to the testers a chart that shows only money going out of the account would be more useful. Additionally, we were suggested to reverse the expense categories list from newest to oldest and to add more details on each expense page. 

\subsection{Future Work}
We received a few suggestions on future implementation of features that the testers wished were present in our app. For instance, people would have liked a popup to show up after clicking the Save button in the profile view saying that the information had been successfully saved and the ability, not only to add but, to remove a category in the Category view.

\section{Conclusion}
Since the day we began planning the implementation of the Expense Tracker until now, we have definitely changed and improved lots of our elements in our application throughout the period of time that we were given. The knowledge and experience that we gained throughout time has motivated us to refactor our existing code and improve its quality. Our main goal was to implement a friendly user interface interaction between the user and the mobile application. We achieved this requirement by relying on the AddExpense view to receive expense from the user of type category. Behind the scenes, special mathematical operations are performed on the expenses and income gathered from the user. As a result, a visual pie chart representation of each expense category is displayed on the chart view. This was a huge achievement in our project which involved hours of deep research and understanding of how objects are laid out and accessed in different views. Overall, Swiftui is very similar to a lot of the languages that we have been working with throughout our undergraduate experience. In general, the language itself is great for IOS mobile application development. Although, understanding its syntax and how data is shared with its views is very conceptual and unique which takes practice and time to develop a basic understanding. As any other application, it is important to improve and enhance applications. Unfortunately, for the purpose of this project, we do not have enough time to expand on the applications’ features. In the future, we plan to improve the style of Expense Tracker as well as adding more features such as delete expense, detailed profile view, linking personal bank accounts and many more creative features.


\bibliographystyle{plain}
\bibliography{references}

\end{document}